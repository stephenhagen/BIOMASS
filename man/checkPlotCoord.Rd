% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/checkPlotCoord.R
\name{checkPlotCoord}
\alias{checkPlotCoord}
\title{Check coordinates of plot corners and trees}
\usage{
checkPlotCoord(
  projCoord = NULL,
  longlat = NULL,
  relCoord,
  trustGPScorners,
  cornerID = NULL,
  maxDist = 15,
  rmOutliers = TRUE,
  drawPlot = TRUE,
  treeCoord = NULL
)
}
\arguments{
\item{projCoord}{(optional, if longlat is not supplied) a data frame containing the plot corner coordinates in a projected coordinate system, with X and Y corresponding to the first and second columns respectively.}

\item{longlat}{(optional, if projCoord is not supplied) a data frame containing the plot corner coordinates in longitude and latitude, with longitude and latitude corresponding to the first and second columns respectively}

\item{relCoord}{a data frame containing the plot corner coordinates in the relative coordinates system (that of the field), with X and Y corresponding to the first and second columns respectively, and with the same row order than longlat or projCoord}

\item{trustGPScorners}{a logical indicating whether or not you trust the GPS coordinates of the plot's corners. See details.}

\item{cornerID}{a vector indicating the ID of the corners (e.g c("SE","SE",...)) in the case you have multiple measurements for each corner}

\item{maxDist}{a numeric giving the maximum distance (in meters) above which GPS measurements should be considered outliers (default 15 m)}

\item{rmOutliers}{a logical indicating if detected outliers are removed from the coordinate calculation}

\item{drawPlot}{a logical indicating if the plot design should be displayed and returned}

\item{treeCoord}{(optional) a data frame containing at least the relative tree coordinates (field/local coordinates), with X and Y corresponding to the first and second columns respectively}
}
\value{
Returns a list including :
\itemize{
\item \code{cornerCoord}: a data frame containing the projected and relative coordinates, the ID (if cornerID is supplied) and the number of the 4 corners of the plot
\item \code{polygon}: a spatial polygon
\item \code{outliers}: a data frame containing the projected coordinates, the ID (if cornerID is supplied) and the row number of GPS points considered outliers
\item \code{plotDesign}: if \code{drawPlot} is TRUE, a ggplot object corresponding to the design of the plot
\item \code{codeUTM}: if \code{longlat} is supplied, a character containing the UTM code of the GPS coordinates
\item \code{treeProjCoord}: if \code{treeCoord} is supplied, a data frame containing the coordinates of the trees in the projected coordinate system
}
}
\description{
Quality check of plot corner and tree coordinates.
}
\details{
If trustGPScorners is TRUE, corner coordinates in the projected coordinate system are averaging by corner (if multiple measures) and outlier corners are identified sequentially using these averages and the maxDist argument. Then, projected coordinates of the trees are calculated from the local coordinates using a bilinear interpolation that follows the correspondence of the corners between these two coordinate systems. Be aware that this projection only works if the plot, in the relative coordinates system, is rectangular (ie, has 4 right angles).

If trustGPScorners is FALSE, corner coordinates in the projected coordinate system are calculated by a procrust analysis that preserves the shape and dimensions of the plot in the local coordinate system. Outlier corners are also identified sequentially and projected coordinates of the trees are calculated by applying the resulting procrust analysis.

If longlat is supplied instead of projCoord, the function will first convert the long/lat coordinates into UTM coordinates. An error may result if the parcel is located right between two UTM zones. In this case, the user has to convert himself his long/lat coordinates into any projected coordinates which have the same dimension than his local coordinates (in meters most of the time).
}
\examples{
projCoord <- data.frame(
  X = c(
    runif(5, min = 9, max = 11), runif(5, min = 8, max = 12),
    runif(5, min = 80, max = 120), runif(5, min = 90, max = 110)
  ),
  Y = c(
    runif(5, min = 9, max = 11), runif(5, min = 80, max = 120),
    runif(5, min = 8, max = 12), runif(5, min = 90, max = 110)
  )
)
projCoord <- projCoord + 1000
relCoord <- data.frame(
  X = c(rep(0, 10), rep(100, 10)),
  Y = c(rep(c(rep(0, 5), rep(100, 5)), 2))
)
cornerID <- rep(c("SW","NW","SE","NE"),e=5)

aa <- checkPlotCoord(
  projCoord = projCoord, relCoord = relCoord,
  trustGPScorners = TRUE, cornerID = cornerID,
  rmOutliers = FALSE , drawPlot = FALSE
)
bb <- checkPlotCoord(
  projCoord = projCoord, relCoord = relCoord,
  trustGPScorners = FALSE, 
  rmOutliers = TRUE, maxDist = 10,
  drawPlot = FALSE
)
\donttest{
checkPlotCoord(
  projCoord = projCoord, relCoord = relCoord,
  trustGPScorners = TRUE, cornerID = cornerID,
  rmOutliers = TRUE , maxDist = 10,
  drawPlot = TRUE
)
}

}
\author{
Arthur PERE, Maxime REJOU-MECHAIN, Arthur BAILLY
}
